#! /usr/bin/python -E
# Authors: Karl MacMillan <kmacmillan@mentalrootkit.com>
#
# Copyright (C) 2007  Red Hat
# see file 'COPYING' for use and warranty information
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#


# requires the following packages:
# fedora-ds-base
# openldap-clients
# nss-tools

import sys
import os
import socket
import errno
import logging
import pwd
import subprocess
import signal
import shutil
import glob
import traceback
from optparse import OptionParser

import ipaserver.dsinstance
import ipaserver.krbinstance
import ipaserver.bindinstance
import ipaserver.httpinstance
import ipaserver.ntpinstance

from ipaserver import service
from ipaserver import version
from ipaserver.installutils import *

from ipa import sysrestore
from ipa.ipautil import *

def parse_options():
    parser = OptionParser(version=version.VERSION)
    parser.add_option("-u", "--user", dest="ds_user",
                      help="ds user")
    parser.add_option("-r", "--realm", dest="realm_name",
                      help="realm name")
    parser.add_option("-n", "--domain", dest="domain_name",
                      help="domain name")
    parser.add_option("-p", "--ds-password", dest="dm_password",
                      help="admin password")
    parser.add_option("-P", "--master-password", dest="master_password",
                      help="kerberos master password (normally autogenerated)")
    parser.add_option("-a", "--admin-password", dest="admin_password",
                      help="admin user kerberos password")
    parser.add_option("-d", "--debug", dest="debug", action="store_true",
                      default=False, help="print debugging information")
    parser.add_option("--hostname", dest="host_name", help="fully qualified name of server")
    parser.add_option("--ip-address", dest="ip_address", help="Master Server IP Address")
    parser.add_option("--setup-bind", dest="setup_bind", action="store_true",
                      default=False, help="configure bind with our zone file")
    parser.add_option("-U", "--unattended", dest="unattended", action="store_true",
                      default=False, help="unattended installation never prompts the user")
    parser.add_option("", "--uninstall", dest="uninstall", action="store_true",
                      default=False, help="uninstall an existing installation")
    parser.add_option("-N", "--no-ntp", dest="conf_ntp", action="store_false",
                      help="do not configure ntp", default=True)

    options, args = parser.parse_args()

    if options.uninstall:
        if (options.ds_user or options.realm_name or
            options.dm_password or options.admin_password or
            options.master_password):
            parser.error("error: In uninstall mode, -u, r, -p and -P options are not allowed")
    elif options.unattended:
        if (not options.ds_user or not options.realm_name or
            not options.dm_password or not options.admin_password):
            parser.error("error: In unattended mode you need to provide at least -u, -r, -p and -a options")

    return options

def signal_handler(signum, frame):
    global ds
    print "\nCleaning up..."
    if ds:
        print "Removing configuration for %s instance" % ds.serverid
        ds.stop()
        if ds.serverid:
            ipaserver.dsinstance.erase_ds_instance_data (ds.serverid)
    sys.exit(1)

def read_host_name(host_default):
    host_ok = False
    host_name = ""

    print "Enter the fully qualified domain name of the computer"
    print "on which you're setting up server software. Using the form"
    print "<hostname>.<domainname>"
    print "Example: master.example.com."
    print ""
    print ""
    if host_default == "":
        host_default = "master.example.com"
    while not host_ok:
        host_input = raw_input("Server host name [" + host_default + "]: ")
        print ""
        if host_input == "":
            host_name = host_default
        else:
            host_name = host_input
        try:
            verify_fqdn(host_name)
        except Exception, e:
            raise e
        else:
            host_ok = True
    return host_name

def resolve_host(host_name):
    ip = ""
    try:
        ip = socket.gethostbyname(host_name)

        if ip == "127.0.0.1" or ip == "::1":
            print "The hostname resolves to the localhost address (127.0.0.1/::1)"
            print "Please change your /etc/hosts file so that the hostname"
            print "resolves to the ip address of your network interface."
            print "The KDC service does not listen on localhost"
            print ""
            print "Please fix your /etc/hosts file and restart the setup program"
            return "-Fatal Error-"

    except:
        print "Unable to lookup the IP address of the provided host"
    return ip

def verify_ip_address(ip):
    is_ok = True
    try:
        socket.inet_pton(socket.AF_INET, ip)
    except:
        try:
            socket.inet_pton(socket.AF_INET6, ip)
        except:
            print "Unable to verify IP address"
            is_ok = False
    return is_ok

def read_ip_address(host_name):
    while True:
        ip = raw_input("Please provide the IP address to be used for this host name: ")

        if ip == "":
            continue
        if ip == "127.0.0.1" or ip == "::1":
            print "The IPA Server can't use localhost as a valid IP"
            continue

        if not verify_ip_address(ip):
            continue

        print "Adding ["+ip+" "+host_name+"] to your /etc/hosts file"
        fstore.backup_file("/etc/hosts")
        hosts_fd = open('/etc/hosts', 'r+')
        hosts_fd.seek(0, 2)
        hosts_fd.write(ip+'\t'+host_name+' '+host_name.split('.')[0]+'\n')
        hosts_fd.close()

        return ip

def read_ds_user():
    print "The server must run as a specific user in a specific group."
    print "It is strongly recommended that this user should have no privileges"
    print "on the computer (i.e. a non-root user).  The setup procedure"
    print "will give this user/group some permissions in specific paths/files"
    print "to perform server-specific operations."
    print ""

    ds_user = ""
    try:
        pwd.getpwnam('dirsrv')

        print "A user account named 'dirsrv' already exists. This is the user id"
        print "that the Directory Server will run as."
        print ""
        yesno = raw_input("Do you want to use the existing 'dirsrv' account? [yes]: ")
        print ""
        if not yesno or yesno.lower()[0] != "n":
            ds_user = "dirsrv"
        else:
            ds_user = raw_input("Which account name do you want to use for the DS instance? ")
            print ""
    except KeyError:
        ds_user = "dirsrv"

    return ds_user

def read_domain_name(domain_name, unattended):
    print "The domain name has been calculated based on the host name."
    print ""
    if not unattended:
        dn = raw_input("Please confirm the domain name ["+domain_name+"]: ")
        print ""
        if dn != "":
            domain_name = dn
    return domain_name

def read_realm_name(domain_name, unattended):
    print "The kerberos protocol requires a Realm name to be defined."
    print "This is typically the domain name converted to uppercase."
    print ""
    upper_dom = domain_name.upper()
    if unattended:
        realm_name = upper_dom
    else:
        realm_name = raw_input("Please provide a realm name ["+upper_dom+"]: ")
        print ""
        if realm_name == "":
            realm_name = upper_dom
        else:
            upper_dom = realm_name.upper()
        if upper_dom != realm_name:
            print "It is strongly recommended that you use a completely uppercased name for the realm."
            dom_realm = raw_input("Do you want to use "+upper_dom+" as realm name ? [yes]: ")
            print ""
            if dom_realm and dom_realm.lower()[0] != "y":
                print "WARNING: Using a non upper-cased realm name may cause unexpected problems."
            else:
                realm_name = upper_dom
    return realm_name

def read_dm_password():
    print "Certain directory server operations require an administrative user."
    print "This user is referred to as the Directory Manager and has full access"
    print "to the Directory for system management tasks and will be added to the"
    print "instance of directory server created for IPA."
    print "The password must be at least 8 characters long."
    print ""
    #TODO: provide the option of generating a random password
    dm_password = read_password("Directory Manager")
    return dm_password

def read_admin_password():
    print "The IPA server requires an administrative user, named 'admin'."
    print "This user is a regular system account used for IPA server administration."
    print ""
    #TODO: provide the option of generating a random password
    admin_password = read_password("IPA admin")
    return admin_password

def check_dirsrv():
    serverids = ipaserver.dsinstance.check_existing_installation()
    if serverids:
        print ""
        print "An existing Directory Server has been detected."
        yesno = raw_input("Do you wish to remove it and create a new one? [no]: ")
        if not yesno or yesno.lower()[0] != "y":
            print ""
            print "Only a single Directory Server instance is allowed on an IPA"
            print "server, the one used by IPA itself."
            sys.exit(1)

        try:
            service.stop("dirsrv")
        except:
            pass

        for serverid in serverids:
            ipaserver.dsinstance.erase_ds_instance_data(serverid)

    (ds_unsecure, ds_secure) = ipaserver.dsinstance.check_ports()
    if not ds_unsecure or not ds_secure:
        print "IPA requires ports 389 and 636 for the Directory Server."
        print "These are currently in use:"
        if not ds_unsecure:
            print "\t389"
        if not ds_secure:
            print "\t636"
        sys.exit(1)

def uninstall():
    try:
        run(["/usr/sbin/ipa-client-install", "--on-master", "--unattended", "--uninstall"])
    except Exception, e:
        print "Uninstall of client side components failed!"
        print "ipa-client-install returned: " + str(e)
        pass

    ipaserver.ntpinstance.NTPInstance(fstore).uninstall()
    ipaserver.bindinstance.BindInstance(fstore).uninstall()
    ipaserver.httpinstance.WebGuiInstance().uninstall()
    ipaserver.httpinstance.HTTPInstance(fstore).uninstall()
    ipaserver.krbinstance.KrbInstance(fstore).uninstall()
    ipaserver.dsinstance.DsInstance().uninstall()
    fstore.restore_all_files()
    return 0

def main():
    global ds
    ds = None

    options = parse_options()

    if os.getegid() != 0:
        print "Must be root to setup server"
        return

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    if options.uninstall:
        standard_logging_setup("/var/log/ipaserver-uninstall.log", options.debug)
    else:
        standard_logging_setup("/var/log/ipaserver-install.log", options.debug)
        print "\nThe log file for this installation can be found in /var/log/ipaserver-install.log"

    global fstore
    fstore = sysrestore.FileStore('/var/lib/ipa/sysrestore')

    if options.uninstall:
        if not options.unattended:
            print "\nThis is a NON REVERSIBLE operation and will delete all data and configuration!\n"
            yesno = raw_input("Are you sure you want to continue with the uninstall proceedure?:[NO/yes] ")
            if not yesno or yesno.lower() != "yes":
                print ""
                print "Aborting uninstall operation."
                sys.exit(1)

        return uninstall()

    print "=============================================================================="
    print "This program will setup the FreeIPA Server."
    print ""
    print "This includes:"
    print "  * Configure the Network Time Daemon (ntpd)"
    print "  * Create and configure an instance of Directory Server"
    print "  * Create and configure a Kerberos Key Distribution Center (KDC)"
    print "  * Configure Apache (httpd)"
    print "  * Configure TurboGears"
    print ""
    print "To accept the default shown in brackets, press the Enter key."
    print ""

    check_dirsrv()

    ds_user = ""
    realm_name = ""
    host_name = ""
    domain_name = ""
    ip_address = ""
    master_password = ""
    dm_password = ""
    admin_password = ""

    # check bind packages are installed
    bind = ipaserver.bindinstance.BindInstance()
    if options.setup_bind:
        if not bind.check_inst():
            print "--setup-bind was specified but bind is not installed on the system"
            print "Please install bind (you may also need the package 'caching-nameserver') and restart the setup program"
            return "-Fatal Error-"

    # check the hostname is correctly configured, it must be as the kldap
    # utilities just use the hostname as returned by gethostbyname to set
    # up some of the standard entries

    host_default = ""
    if options.host_name:
        host_default = options.host_name
    else:
        host_default = get_fqdn()

    if options.unattended:
        try:
            verify_fqdn(host_default)
        except RuntimeError, e:
            logging.error(str(e) + "\n")
            return "-Fatal Error-"

        host_name = host_default
    else:
        host_name = read_host_name(host_default)

    if not options.domain_name:
        domain_name = read_domain_name(host_name[host_name.find(".")+1:], options.unattended)
    else:
        domain_name = options.domain_name

    # Check we have a public IP that is associated with the hostname
    ip = resolve_host(host_name)
    if not ip:
        if options.ip_address:
            ip = options.ip_address
    if not ip and options.unattended:
        print "Unable to resolve IP address for host name"
        return "-Fatal Error-"

    if not verify_ip_address(ip):
        ip = ""
        if options.unattended:
            return "-Fatal Error-"

    if options.ip_address and options.ip_address != ip:
        if options.setup_bind:
            ip = options.ip_address
        else:
            print "Error: the hostname resolves to an IP address that is different"
            print "from the one provided on the command line.  Please fix your DNS"
            print "or /etc/hosts file and restart the installation."
            return "-Fatal Error-"

    if options.unattended:
        if not ip:
            print "Unable to resolve IP address"
            return "-Fatal Error-"

    if not ip:
        ip = read_ip_address(host_name)
    ip_address = ip

    print "The IPA Master Server will be configured with"
    print "Hostname:    " + host_name
    print "IP address:  " + ip_address
    print "Domain name: " + domain_name
    print ""

    if not options.ds_user:
        ds_user = read_ds_user()
        if ds_user == "":
            return "-Aborted-"
    else:
        ds_user = options.ds_user

    if not options.realm_name:
        realm_name = read_realm_name(domain_name, options.unattended)
    else:
        realm_name = options.realm_name

    if not options.dm_password:
        dm_password = read_dm_password()
    else:
        dm_password = options.dm_password

    if not options.master_password:
        master_password = ipa_generate_password()
    else:
        master_password = options.master_password

    if not options.admin_password:
        admin_password = read_admin_password()
    else:
        admin_password = options.admin_password

    if not options.unattended:
        print ""
        print "The following operations may take some minutes to complete."
        print "Please wait until the prompt is returned."

    # Configure ntpd
    if options.conf_ntp:
        ntp = ipaserver.ntpinstance.NTPInstance(fstore)
        ntp.create_instance()

    # Create a directory server instance
    ds = ipaserver.dsinstance.DsInstance()
    ds.create_instance(ds_user, realm_name, host_name, domain_name, dm_password)

    # Create a kerberos instance
    krb = ipaserver.krbinstance.KrbInstance(fstore)
    krb.create_instance(ds_user, realm_name, host_name, domain_name, dm_password, master_password)

    # Create a HTTP instance
    http = ipaserver.httpinstance.HTTPInstance(fstore)
    http.create_instance(realm_name, host_name, domain_name)

    # Create the config file
    fstore.backup_file("/etc/ipa/ipa.conf")
    fd = open("/etc/ipa/ipa.conf", "w")
    fd.write("[defaults]\n")
    fd.write("server=" + host_name + "\n")
    fd.write("realm=" + realm_name + "\n")
    fd.close()

    # Create a Web Gui instance
    webgui = ipaserver.httpinstance.WebGuiInstance()
    webgui.create_instance()

    bind.setup(host_name, ip_address, realm_name, domain_name)
    if options.setup_bind:
        bind.create_instance()
    else:
        bind.create_sample_bind_zone()

    # Restart ds and krb after configurations have been changed
    service.print_msg("restarting the directory server")
    ds.restart()

    service.print_msg("restarting the KDC")
    krb.restart()

    # Set the admin user kerberos password
    ds.change_admin_password(admin_password)

    # Call client install script
    try:
        run(["/usr/sbin/ipa-client-install", "--on-master", "--unattended", "--domain", domain_name, "--server", host_name, "--realm", realm_name])
    except Exception, e:
        print "Configuration of client side components failed!"
        print "ipa-client-install returned: " + str(e)
        return "-Fatal Error-"

    print "=============================================================================="
    print "Setup complete"
    print ""
    print "Next steps:"
    print "\t1. You may need to open some network ports - specifically:"
    print "\t\tTCP Ports:"
    print "\t\t  * 80, 443: HTTP/HTTPS"
    print "\t\t  * 389, 636: LDAP/LDAPS"
    print "\t\t  * 88, 464: kerberos"
    print "\t\tUDP Ports:"
    print "\t\t  * 88, 464: kerberos"
    print "\t\t  * 123: ntp"
    print ""
    print "\t2. You can now obtain a kerberos ticket using the command: 'kinit admin'"
    print "\t   This ticket will allow you to use the IPA tools (e.g., ipa-adduser)"
    print "\t   and the web user interface."

    if not service.is_running("ntpd"):
        print "\t3. Kerberos requires time synchronization between clients"
        print "\t   and servers for correct operation. You should consider enabling ntpd."

    print ""
    print "Be sure to back up the CA certificate stored in " + ipaserver.dsinstance.config_dirname(ds.serverid) + "cacert.p12"
    print "The password for this file is in " + ipaserver.dsinstance.config_dirname(ds.serverid) + "pwdfile.txt"

    return 0

try:
    main()
    sys.exit(0)
except SystemExit, e:
    sys.exit(e)
except Exception, e:
    message = "Unexpected error - see ipaserver-install.log for details:\n %s" % str(e)
    print message
    message = str(e)
    for str in traceback.format_tb(sys.exc_info()[2]):
        message = message + "\n" + str
    logging.debug(message)
    sys.exit(1)
